// src/WalletCore.ts
import { HexString, TxnBuilderTypes as TxnBuilderTypes2, BCS as BCS2 } from "aptos";
import {
  AccountAuthenticatorEd25519,
  Ed25519PublicKey,
  Ed25519Signature,
  AptosConfig,
  generateTransactionPayload
} from "@aptos-labs/ts-sdk";
import EventEmitter2 from "eventemitter3";
import nacl from "tweetnacl";
import { Buffer } from "buffer";

// src/constants.ts
var WalletReadyState = /* @__PURE__ */ ((WalletReadyState2) => {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName = /* @__PURE__ */ ((NetworkName2) => {
  NetworkName2["Mainnet"] = "mainnet";
  NetworkName2["Testnet"] = "testnet";
  NetworkName2["Devnet"] = "devnet";
  return NetworkName2;
})(NetworkName || {});

// src/error/index.ts
var WalletError = class extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
};
var WalletNotSelectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};
var WalletNotReadyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
};
var WalletConnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
};
var WalletDisconnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
};
var WalletAccountError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
};
var WalletGetNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
};
var WalletAccountChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountChangeError";
  }
};
var WalletNetworkChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNetworkChangeError";
  }
};
var WalletNotConnectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
};
var WalletSignMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
};
var WalletSignMessageAndVerifyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageAndVerifyError";
  }
};
var WalletSignAndSubmitMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignAndSubmitMessageError";
  }
};
var WalletSignTransactionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
};
var WalletNotSupportedMethod = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSupportedMethod";
  }
};

// src/utils/scopePollingDetectionStrategy.ts
function scopePollingDetectionStrategy(detect) {
  if (typeof window === "undefined" || typeof document === "undefined")
    return;
  const disposers = [];
  function detectAndDispose() {
    const detected = detect();
    if (detected) {
      for (const dispose of disposers) {
        dispose();
      }
    }
  }
  const interval = setInterval(detectAndDispose, 1e3);
  disposers.push(() => clearInterval(interval));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", detectAndDispose, {
      once: true
    });
    disposers.push(
      () => document.removeEventListener("DOMContentLoaded", detectAndDispose)
    );
  }
  if (document.readyState !== "complete") {
    window.addEventListener("load", detectAndDispose, { once: true });
    disposers.push(() => window.removeEventListener("load", detectAndDispose));
  }
  detectAndDispose();
}

// src/utils/localStorage.ts
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}

// src/utils/helpers.ts
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(
    navigator.userAgent
  );
}
function isInAppBrowser() {
  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
    navigator.userAgent
  );
  const isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(
    navigator.userAgent
  );
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator)
    return false;
  return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
  return typeof error === "object" && "message" in error ? error.message : error;
}

// src/ans.ts
var ChainIdToAnsContractAddressMap = {
  "1": "mainnet",
  "2": "testnet"
};
var getNameByAddress = async (chainId, address) => {
  try {
    if (!ChainIdToAnsContractAddressMap[chainId])
      return null;
    const response = await fetch(
      `https://www.aptosnames.com/api/${ChainIdToAnsContractAddressMap[chainId]}/v1/name/${address}`
    );
    const data = await response.json();
    return data.name;
  } catch (e) {
    console.log("error", e);
    return null;
  }
};

// src/conversion.ts
import {
  Network,
  TypeTag
} from "@aptos-labs/ts-sdk";
import { BCS, TxnBuilderTypes } from "aptos";
function convertNetwork(networkInfo) {
  switch (networkInfo == null ? void 0 : networkInfo.name.toLowerCase()) {
    case "mainnet":
      return Network.MAINNET;
    case "testnet":
      return Network.TESTNET;
    case "devnet":
      return Network.DEVNET;
    default:
      throw new Error("Invalid network name");
  }
}
function convertV2TransactionPayloadToV1BCSPayload(payload) {
  const deserializer = new BCS.Deserializer(payload.bcsToBytes());
  return TxnBuilderTypes.TransactionPayload.deserialize(deserializer);
}
function convertV2PayloadToV1JSONPayload(payload) {
  var _a;
  if ("bytecode" in payload) {
    throw new Error("script payload not supported");
  } else {
    const stringTypeTags = (_a = payload.typeArguments) == null ? void 0 : _a.map(
      (typeTag) => {
        if (typeTag instanceof TypeTag) {
          return typeTag.toString();
        }
        return typeTag;
      }
    );
    const newPayload = {
      type: "entry_function_payload",
      function: payload.function,
      type_arguments: stringTypeTags || [],
      arguments: payload.functionArguments
    };
    return newPayload;
  }
}

// src/WalletCoreV1.ts
import EventEmitter from "eventemitter3";
var WalletCoreV1 = class extends EventEmitter {
  async signAndSubmitTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signAndSubmitTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signAndSubmitBCSTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signAndSubmitBCSTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
};

// src/WalletCore.ts
var WalletCore = class extends EventEmitter2 {
  constructor(plugins) {
    super();
    this._wallets = [];
    this._wallet = null;
    this._account = null;
    this._network = null;
    this.waletCoreV1 = new WalletCoreV1();
    this._connecting = false;
    this._connected = false;
    this._wallets = plugins;
    this.scopePollingDetectionStrategy();
  }
  scopePollingDetectionStrategy() {
    var _a;
    (_a = this._wallets) == null ? void 0 : _a.forEach((wallet) => {
      if (!wallet.readyState) {
        wallet.readyState = typeof window === "undefined" || typeof document === "undefined" ? "Unsupported" /* Unsupported */ : "NotDetected" /* NotDetected */;
      }
      if (typeof window !== "undefined") {
        scopePollingDetectionStrategy(() => {
          const providerName = wallet.providerName || wallet.name.toLowerCase();
          if (Object.keys(window).includes(providerName)) {
            wallet.readyState = "Installed" /* Installed */;
            wallet.provider = window[providerName];
            this.emit("readyStateChange", wallet);
            return true;
          }
          return false;
        });
      }
    });
  }
  doesWalletExist() {
    if (!this._connected || this._connecting || !this._wallet)
      throw new WalletNotConnectedError().name;
    if (!(this._wallet.readyState === "Loadable" /* Loadable */ || this._wallet.readyState === "Installed" /* Installed */))
      throw new WalletNotReadyError().name;
    return true;
  }
  clearData() {
    this._connected = false;
    this.setWallet(null);
    this.setAccount(null);
    this.setNetwork(null);
    removeLocalStorage();
  }
  async setAnsName() {
    var _a;
    if (((_a = this._network) == null ? void 0 : _a.chainId) && this._account) {
      const name = await getNameByAddress(
        this._network.chainId,
        this._account.address
      );
      this._account.ansName = name;
    }
  }
  setWallet(wallet) {
    this._wallet = wallet;
  }
  setAccount(account) {
    this._account = account;
  }
  setNetwork(network) {
    this._network = network;
  }
  isConnected() {
    return this._connected;
  }
  get wallets() {
    return this._wallets;
  }
  get wallet() {
    try {
      if (!this._wallet)
        return null;
      return {
        name: this._wallet.name,
        icon: this._wallet.icon,
        url: this._wallet.url
      };
    } catch (error) {
      throw new WalletNotSelectedError(error).message;
    }
  }
  get account() {
    try {
      return this._account;
    } catch (error) {
      throw new WalletAccountError(error).message;
    }
  }
  get network() {
    try {
      return this._network;
    } catch (error) {
      throw new WalletGetNetworkError(error).message;
    }
  }
  async connect(walletName) {
    var _a;
    const selectedWallet = (_a = this._wallets) == null ? void 0 : _a.find(
      (wallet) => wallet.name === walletName
    );
    if (!selectedWallet)
      return;
    if (this._connected) {
      if (selectedWallet.name === walletName)
        throw new WalletConnectionError(
          `${walletName} wallet is already connected`
        ).message;
    }
    if (isRedirectable()) {
      if (selectedWallet.deeplinkProvider) {
        const url = encodeURIComponent(window.location.href);
        const location = selectedWallet.deeplinkProvider({ url });
        window.location.href = location;
      }
    }
    if (selectedWallet.readyState !== "Installed" /* Installed */ && selectedWallet.readyState !== "Loadable" /* Loadable */) {
      return;
    }
    await this.connectWallet(selectedWallet);
  }
  async connectWallet(selectedWallet) {
    try {
      this._connecting = true;
      this.setWallet(selectedWallet);
      const account = await selectedWallet.connect();
      this.setAccount({ ...account });
      const network = await selectedWallet.network();
      this.setNetwork({ ...network });
      await this.setAnsName();
      setLocalStorage(selectedWallet.name);
      this._connected = true;
      this.emit("connect", account);
    } catch (error) {
      this.clearData();
      const errMsg = generalizedErrorMessage(error);
      throw new WalletConnectionError(errMsg).message;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.disconnect());
      this.clearData();
      this.emit("disconnect");
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletDisconnectionError(errMsg).message;
    }
  }
  async signAndSubmitTransaction(transactionInput) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    try {
      this.doesWalletExist();
      if (((_a = this._wallet) == null ? void 0 : _a.version) === "v2") {
        const response2 = await this._wallet.signAndSubmitTransaction({
          ...transactionInput,
          sender: (_b = transactionInput.sender) != null ? _b : this._account.address
        });
        return response2;
      }
      const payloadData = transactionInput.data;
      if (typeof payloadData.functionArguments[0] === "object") {
        const aptosConfig = new AptosConfig({
          network: convertNetwork(this._network)
        });
        const newPayload = await generateTransactionPayload({
          ...payloadData,
          aptosConfig
        });
        const oldTransactionPayload2 = convertV2TransactionPayloadToV1BCSPayload(newPayload);
        const response2 = await this.waletCoreV1.signAndSubmitBCSTransaction(
          oldTransactionPayload2,
          this._wallet,
          {
            max_gas_amount: ((_c = transactionInput.options) == null ? void 0 : _c.maxGasAmount) ? BigInt((_d = transactionInput.options) == null ? void 0 : _d.maxGasAmount) : void 0,
            gas_unit_price: ((_e = transactionInput.options) == null ? void 0 : _e.gasUnitPrice) ? BigInt((_f = transactionInput.options) == null ? void 0 : _f.gasUnitPrice) : void 0
          }
        );
        const { hash: hash2, ...output2 } = response2;
        return { hash: hash2, output: output2 };
      }
      const oldTransactionPayload = convertV2PayloadToV1JSONPayload(payloadData);
      const response = await this.waletCoreV1.signAndSubmitTransaction(
        oldTransactionPayload,
        this._wallet,
        {
          max_gas_amount: ((_g = transactionInput.options) == null ? void 0 : _g.maxGasAmount) ? BigInt((_h = transactionInput.options) == null ? void 0 : _h.maxGasAmount) : void 0,
          gas_unit_price: ((_i = transactionInput.options) == null ? void 0 : _i.gasUnitPrice) ? BigInt((_j = transactionInput.options) == null ? void 0 : _j.gasUnitPrice) : void 0
        }
      );
      const { hash, ...output } = response;
      return { hash, output };
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transactionOrPayload, asFeePayer, options) {
    var _a, _b, _c;
    try {
      this.doesWalletExist();
      if ("rawTransaction" in transactionOrPayload) {
        if (((_a = this._wallet) == null ? void 0 : _a.version) !== "v2") {
          throw new WalletNotSupportedMethod(
            `Sign Transaction V2 is not supported by ${(_b = this.wallet) == null ? void 0 : _b.name}`
          ).message;
        }
        const accountAuthenticator2 = this._wallet.signTransaction(
          transactionOrPayload,
          asFeePayer
        );
        return accountAuthenticator2;
      }
      if (this._wallet && !("signTransaction" in this._wallet)) {
        throw new WalletNotSupportedMethod(
          `Sign Transaction is not supported by ${(_c = this.wallet) == null ? void 0 : _c.name}`
        ).message;
      }
      const response = await this.waletCoreV1.signTransaction(
        transactionOrPayload,
        this._wallet,
        {
          max_gas_amount: (options == null ? void 0 : options.maxGasAmount) ? BigInt(options == null ? void 0 : options.maxGasAmount) : void 0,
          gas_unit_price: (options == null ? void 0 : options.gasUnitPrice) ? BigInt(options == null ? void 0 : options.gasUnitPrice) : void 0
        }
      );
      if (!response) {
        throw new Error("error");
      }
      const deserializer1 = new BCS2.Deserializer(response);
      const deserializedSignature = TxnBuilderTypes2.SignedTransaction.deserialize(deserializer1);
      const transactionAuthenticator = deserializedSignature.authenticator;
      const publicKey = transactionAuthenticator.public_key.value;
      const signature = transactionAuthenticator.signature.value;
      const accountAuthenticator = new AccountAuthenticatorEd25519(
        new Ed25519PublicKey(publicKey),
        new Ed25519Signature(signature)
      );
      return accountAuthenticator;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessage(message) {
    try {
      this.doesWalletExist();
      const response = await this._wallet.signMessage(message);
      return response;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async submitTransaction(transaction) {
    var _a;
    if (this._wallet && !("submitTransaction" in this._wallet)) {
      throw new WalletNotSupportedMethod(
        `Submit Transaction is not supported by ${(_a = this.wallet) == null ? void 0 : _a.name}`
      ).message;
    }
    try {
      this.doesWalletExist();
      const pendingTransaction = this._wallet.submitTransaction(
        transaction
      );
      return pendingTransaction;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async onAccountChange() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.onAccountChange(async (data) => {
        this.setAccount({ ...data });
        await this.setAnsName();
        this.emit("accountChange", this._account);
      }));
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletAccountChangeError(errMsg).message;
    }
  }
  async onNetworkChange() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.onNetworkChange(async (data) => {
        this.setNetwork({ ...data });
        await this.setAnsName();
        this.emit("networkChange", this._network);
      }));
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletNetworkChangeError(errMsg).message;
    }
  }
  async signMessageAndVerify(message) {
    var _a;
    try {
      this.doesWalletExist();
      if (!this._account)
        throw new Error("No account found!");
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signMessage(message));
      if (!response)
        throw new WalletSignMessageAndVerifyError("Failed to sign a message").message;
      let verified = false;
      if (Array.isArray(response.signature)) {
        const { fullMessage, signature, bitmap } = response;
        if (bitmap) {
          const minKeysRequired = this._account.minKeysRequired;
          if (signature.length < minKeysRequired) {
            verified = false;
          } else {
            const bits = Array.from(bitmap).flatMap(
              (n) => Array.from({ length: 8 }).map((_, i) => n >> i & 1)
            );
            const index = bits.map((_, i) => i).filter((i) => bits[i]);
            const publicKeys = this._account.publicKey;
            const matchedPublicKeys = publicKeys.filter(
              (_, i) => index.includes(i)
            );
            verified = true;
            for (let i = 0; i < signature.length; i++) {
              const isSigVerified = nacl.sign.detached.verify(
                Buffer.from(fullMessage),
                Buffer.from(signature[i], "hex"),
                Buffer.from(matchedPublicKeys[i], "hex")
              );
              if (!isSigVerified) {
                verified = false;
                break;
              }
            }
          }
        } else {
          throw new WalletSignMessageAndVerifyError("Failed to get a bitmap").message;
        }
      } else {
        const currentAccountPublicKey = new HexString(
          this._account.publicKey
        );
        const signature = new HexString(response.signature);
        verified = nacl.sign.detached.verify(
          Buffer.from(response.fullMessage),
          Buffer.from(signature.noPrefix(), "hex"),
          Buffer.from(currentAccountPublicKey.noPrefix(), "hex")
        );
      }
      return verified;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};

// src/types.ts
import { TxnBuilderTypes as TxnBuilderTypes3, Types as Types3 } from "aptos";
export {
  NetworkName,
  TxnBuilderTypes3 as TxnBuilderTypes,
  Types3 as Types,
  WalletCore,
  WalletReadyState,
  generalizedErrorMessage,
  getLocalStorage,
  isInAppBrowser,
  isMobile,
  isRedirectable,
  removeLocalStorage,
  scopePollingDetectionStrategy,
  setLocalStorage
};
