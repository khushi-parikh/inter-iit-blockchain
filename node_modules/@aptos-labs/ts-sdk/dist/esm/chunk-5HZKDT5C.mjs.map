{"version":3,"sources":["../../src/core/crypto/ed25519.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from \"tweetnacl\";\nimport { PublicKey, PrivateKey, Signature } from \"./asymmetricCrypto\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializer } from \"../../bcs/serializer\";\nimport { Hex } from \"../hex\";\nimport { HexInput } from \"../../types\";\nimport { CKDPriv, deriveKey, HARDENED_OFFSET, isValidHardenedPath, mnemonicToSeed, splitPath } from \"./hdKey\";\n\n/**\n * Represents the public key of an Ed25519 key pair.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Ed25519 scheme is represented in the SDK as `Legacy authentication key` and also\n * as `AnyPublicKey` that represents any `Unified authentication key`\n */\nexport class Ed25519PublicKey extends PublicKey {\n  /**\n   * Length of an Ed25519 public key\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * Bytes of the public key\n   * @private\n   */\n  private readonly key: Hex;\n\n  /**\n   * Create a new PublicKey instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Ed25519PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${Ed25519PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the public key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the public key\n   */\n  toString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   * @param args.message a signed message\n   * @param args.signature the signature of the message\n   */\n  verifySignature(args: { message: HexInput; signature: Ed25519Signature }): boolean {\n    const { message, signature } = args;\n    const rawMessage = Hex.fromHexInput(message).toUint8Array();\n    const rawSignature = signature.toUint8Array();\n    return nacl.sign.detached.verify(rawMessage, rawSignature, this.key.toUint8Array());\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PublicKey(bytes);\n  }\n\n  static load(deserializer: Deserializer): Ed25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PublicKey(bytes);\n  }\n\n  // TODO(greg): Currently, we can't put this on the abstract type, because of a circular dependency\n  static isPublicKey(publicKey: PublicKey): publicKey is Ed25519PublicKey {\n    return publicKey instanceof Ed25519PublicKey;\n  }\n}\n\n/**\n * Represents the private key of an Ed25519 key pair.\n */\nexport class Ed25519PrivateKey extends PrivateKey {\n  /**\n   * Length of an Ed25519 private key\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The Ed25519 key seed to use for BIP-32 compatibility\n   * See more {@link https://github.com/satoshilabs/slips/blob/master/slip-0010.md}\n   */\n  static readonly SLIP_0010_SEED = \"ed25519 seed\";\n\n  /**\n   * The Ed25519 signing key\n   * @private\n   */\n  private readonly signingKeyPair: nacl.SignKeyPair;\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * @param hexInput HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const privateKeyHex = Hex.fromHexInput(hexInput);\n    if (privateKeyHex.toUint8Array().length !== Ed25519PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Ed25519PrivateKey.LENGTH}`);\n    }\n\n    // Create keyPair from Private key in Uint8Array format\n    this.signingKeyPair = nacl.sign.keyPair.fromSeed(privateKeyHex.toUint8Array().slice(0, Ed25519PrivateKey.LENGTH));\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the private key\n   */\n  toUint8Array(): Uint8Array {\n    return this.signingKeyPair.secretKey.slice(0, Ed25519PrivateKey.LENGTH);\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key\n   */\n  toString(): string {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n\n  /**\n   * Sign the given message with the private key.\n   *\n   * @param message in HexInput format\n   * @returns Signature\n   */\n  sign(message: HexInput): Ed25519Signature {\n    const hex = Hex.fromHexInput(message);\n    const signature = nacl.sign.detached(hex.toUint8Array(), this.signingKeyPair.secretKey);\n    return new Ed25519Signature(signature);\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PrivateKey(bytes);\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Ed25519PrivateKey\n   */\n  static generate(): Ed25519PrivateKey {\n    const keyPair = nacl.sign.keyPair();\n    return new Ed25519PrivateKey(keyPair.secretKey.slice(0, Ed25519PrivateKey.LENGTH));\n  }\n\n  /**\n   * Derive the Ed25519PublicKey for this private key.\n   *\n   * @returns Ed25519PublicKey\n   */\n  publicKey(): Ed25519PublicKey {\n    const bytes = this.signingKeyPair.publicKey;\n    return new Ed25519PublicKey(bytes);\n  }\n\n  /**\n   * Derives a private key from a mnemonic seed phrase.\n   *\n   * To derive multiple keys from the same phrase, change the path\n   *\n   * IMPORTANT: Ed25519 supports hardened derivation only (since it lacks a key homomorphism,\n   * so non-hardened derivation cannot work)\n   *\n   * @param path the BIP44 path\n   * @param mnemonics the mnemonic seed phrase\n   */\n  static fromDerivationPath(path: string, mnemonics: string): Ed25519PrivateKey {\n    if (!isValidHardenedPath(path)) {\n      throw new Error(`Invalid derivation path ${path}`);\n    }\n    return Ed25519PrivateKey.fromDerivationPathInner(path, mnemonicToSeed(mnemonics));\n  }\n\n  /**\n   * A private inner function so we can separate from the main fromDerivationPath() method\n   * to add tests to verify we create the keys correctly.\n   *\n   * @param path the BIP44 path\n   * @param seed the seed phrase created by the mnemonics\n   * @param offset the offset used for key derivation, defaults to 0x80000000\n   * @returns\n   */\n  private static fromDerivationPathInner(path: string, seed: Uint8Array, offset = HARDENED_OFFSET): Ed25519PrivateKey {\n    const { key, chainCode } = deriveKey(Ed25519PrivateKey.SLIP_0010_SEED, seed);\n\n    const segments = splitPath(path).map((el) => parseInt(el, 10));\n\n    // Derive the child key based on the path\n    const { key: privateKey } = segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n      key,\n      chainCode,\n    });\n    return new Ed25519PrivateKey(privateKey);\n  }\n\n  static isPrivateKey(privateKey: PrivateKey): privateKey is Ed25519PrivateKey {\n    return privateKey instanceof Ed25519PrivateKey;\n  }\n}\n\n/**\n * A signature of a message signed using an Ed25519 private key\n */\nexport class Ed25519Signature extends Signature {\n  /**\n   * Length of an Ed25519 signature\n   */\n  static readonly LENGTH = 64;\n\n  /**\n   * The signature bytes\n   * @private\n   */\n  private readonly data: Hex;\n\n  constructor(hexInput: HexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Ed25519Signature.LENGTH) {\n      throw new Error(`Signature length should be ${Ed25519Signature.LENGTH}`);\n    }\n\n    this.data = hex;\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the signature\n   */\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  /**\n   * Get the signature as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the signature\n   */\n  toString(): string {\n    return this.data.toString();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519Signature(bytes);\n  }\n\n  static load(deserializer: Deserializer): Ed25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519Signature(bytes);\n  }\n\n  static isSignature(signature: Signature): signature is Ed25519Signature {\n    return signature instanceof Ed25519Signature;\n  }\n}\n"],"mappings":"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","names":["nacl","_Ed25519PublicKey","PublicKey","hexInput","hex","Hex","args","message","signature","rawMessage","rawSignature","nacl","serializer","deserializer","bytes","publicKey","Ed25519PublicKey","_Ed25519PrivateKey","PrivateKey","privateKeyHex","Ed25519Signature","keyPair","path","mnemonics","isValidHardenedPath","mnemonicToSeed","seed","offset","HARDENED_OFFSET","key","chainCode","deriveKey","segments","splitPath","el","privateKey","parentKeys","segment","CKDPriv","Ed25519PrivateKey","_Ed25519Signature","Signature"]}