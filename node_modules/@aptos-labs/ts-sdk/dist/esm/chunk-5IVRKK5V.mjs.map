{"version":3,"sources":["../../src/internal/general.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/general}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * general namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getAptosFullNode, postAptosFullNode, postAptosIndexer } from \"../client\";\nimport {\n  AnyNumber,\n  Block,\n  GetChainTopUserTransactionsResponse,\n  GetProcessorStatusResponse,\n  GraphqlQuery,\n  LedgerInfo,\n  LedgerVersionArg,\n  MoveValue,\n  TableItemRequest,\n  ViewRequest,\n  InputViewRequestData,\n} from \"../types\";\nimport { GetChainTopUserTransactionsQuery, GetProcessorStatusQuery } from \"../types/generated/operations\";\nimport { GetChainTopUserTransactions, GetProcessorStatus } from \"../types/generated/queries\";\nimport { ProcessorType } from \"../utils/const\";\n\nexport async function getLedgerInfo(args: { aptosConfig: AptosConfig }): Promise<LedgerInfo> {\n  const { aptosConfig } = args;\n  const { data } = await getAptosFullNode<{}, LedgerInfo>({\n    aptosConfig,\n    originMethod: \"getLedgerInfo\",\n    path: \"\",\n  });\n  return data;\n}\n\nexport async function getBlockByVersion(args: {\n  aptosConfig: AptosConfig;\n  ledgerVersion: AnyNumber;\n  options?: { withTransactions?: boolean };\n}): Promise<Block> {\n  const { aptosConfig, ledgerVersion, options } = args;\n  const { data } = await getAptosFullNode<{}, Block>({\n    aptosConfig,\n    originMethod: \"getBlockByVersion\",\n    path: `blocks/by_version/${ledgerVersion}`,\n    params: { with_transactions: options?.withTransactions },\n  });\n  return data;\n}\n\nexport async function getBlockByHeight(args: {\n  aptosConfig: AptosConfig;\n  blockHeight: AnyNumber;\n  options?: { withTransactions?: boolean };\n}): Promise<Block> {\n  const { aptosConfig, blockHeight, options } = args;\n  const { data } = await getAptosFullNode<{}, Block>({\n    aptosConfig,\n    originMethod: \"getBlockByHeight\",\n    path: `blocks/by_height/${blockHeight}`,\n    params: { with_transactions: options?.withTransactions },\n  });\n  return data;\n}\n\nexport async function getTableItem<T>(args: {\n  aptosConfig: AptosConfig;\n  handle: string;\n  data: TableItemRequest;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, handle, data, options } = args;\n  const response = await postAptosFullNode<TableItemRequest, any>({\n    aptosConfig,\n    originMethod: \"getTableItem\",\n    path: `tables/${handle}/item`,\n    params: { ledger_version: options?.ledgerVersion },\n    body: data,\n  });\n  return response.data as T;\n}\n\nexport async function view<T extends Array<MoveValue> = Array<MoveValue>>(args: {\n  aptosConfig: AptosConfig;\n  payload: InputViewRequestData;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, payload, options } = args;\n  const { data } = await postAptosFullNode<ViewRequest, MoveValue[]>({\n    aptosConfig,\n    originMethod: \"view\",\n    path: \"view\",\n    params: { ledger_version: options?.ledgerVersion },\n    body: {\n      function: payload.function,\n      type_arguments: payload.typeArguments ?? [],\n      arguments: payload.functionArguments ?? [],\n    },\n  });\n\n  return data as T;\n}\n\nexport async function getChainTopUserTransactions(args: {\n  aptosConfig: AptosConfig;\n  limit: number;\n}): Promise<GetChainTopUserTransactionsResponse> {\n  const { aptosConfig, limit } = args;\n  const graphqlQuery = {\n    query: GetChainTopUserTransactions,\n    variables: { limit },\n  };\n\n  const data = await queryIndexer<GetChainTopUserTransactionsQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getChainTopUserTransactions\",\n  });\n\n  return data.user_transactions;\n}\n\nexport async function queryIndexer<T extends {}>(args: {\n  aptosConfig: AptosConfig;\n  query: GraphqlQuery;\n  originMethod?: string;\n}): Promise<T> {\n  const { aptosConfig, query, originMethod } = args;\n  const { data } = await postAptosIndexer<GraphqlQuery, T>({\n    aptosConfig,\n    originMethod: originMethod ?? \"queryIndexer\",\n    path: \"\",\n    body: query,\n    overrides: { WITH_CREDENTIALS: false },\n  });\n  return data;\n}\n\nexport async function getProcessorStatuses(args: { aptosConfig: AptosConfig }): Promise<GetProcessorStatusResponse> {\n  const { aptosConfig } = args;\n\n  const graphqlQuery = {\n    query: GetProcessorStatus,\n  };\n\n  const data = await queryIndexer<GetProcessorStatusQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getProcessorStatuses\",\n  });\n\n  return data.processor_status;\n}\n\nexport async function getIndexerLastSuccessVersion(args: { aptosConfig: AptosConfig }): Promise<number> {\n  const response = await getProcessorStatuses({ aptosConfig: args.aptosConfig });\n  return response[0].last_success_version;\n}\n\nexport async function getProcessorStatus(args: {\n  aptosConfig: AptosConfig;\n  processorType: ProcessorType;\n}): Promise<GetProcessorStatusResponse[0]> {\n  const { aptosConfig, processorType } = args;\n\n  const whereCondition: { processor: { _eq: string } } = {\n    processor: { _eq: processorType.valueOf() },\n  };\n\n  const graphqlQuery = {\n    query: GetProcessorStatus,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const data = await queryIndexer<GetProcessorStatusQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getProcessorStatus\",\n  });\n\n  return data.processor_status[0];\n}\n"],"mappings":"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","names":["getLedgerInfo","args","aptosConfig","data","getAptosFullNode","getBlockByVersion","ledgerVersion","options","getBlockByHeight","blockHeight","getTableItem","handle","postAptosFullNode","view","payload","getChainTopUserTransactions","limit","queryIndexer","GetChainTopUserTransactions","query","originMethod","postAptosIndexer","getProcessorStatuses","GetProcessorStatus","getIndexerLastSuccessVersion","getProcessorStatus","processorType","whereCondition"]}