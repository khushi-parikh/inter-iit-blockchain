{"version":3,"sources":["../../src/core/crypto/anyPublicKey.ts"],"sourcesContent":["import { Serializer, Deserializer } from \"../../bcs\";\nimport { AnyPublicKeyVariant, HexInput } from \"../../types\";\nimport { AnySignature } from \"./anySignature\";\nimport { PublicKey } from \"./asymmetricCrypto\";\nimport { Ed25519PublicKey } from \"./ed25519\";\nimport { Secp256k1PublicKey } from \"./secp256k1\";\n\n/**\n * Represents any public key supported by Aptos.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Any unified authentication key is represented in the SDK as `AnyPublicKey`.\n */\nexport class AnyPublicKey extends PublicKey {\n  /**\n   * Reference to the inner public key\n   */\n  public readonly publicKey: PublicKey;\n\n  constructor(publicKey: PublicKey) {\n    super();\n    this.publicKey = publicKey;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.publicKey.toUint8Array();\n  }\n\n  /**\n   * Get the public key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the public key\n   */\n  toString(): string {\n    return this.publicKey.toString();\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   *\n   * @param args.message message\n   * @param args.signature The signature\n   * @returns true if the signature is valid\n   */\n  verifySignature(args: { message: HexInput; signature: AnySignature }): boolean {\n    const { message, signature } = args;\n    return this.publicKey.verifySignature({ message, signature });\n  }\n\n  serialize(serializer: Serializer): void {\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      serializer.serializeU32AsUleb128(AnyPublicKeyVariant.Ed25519);\n      this.publicKey.serialize(serializer);\n    } else if (this.publicKey instanceof Secp256k1PublicKey) {\n      serializer.serializeU32AsUleb128(AnyPublicKeyVariant.Secp256k1);\n      this.publicKey.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown public key type\");\n    }\n  }\n\n  static deserialize(deserializer: Deserializer): AnyPublicKey {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case AnyPublicKeyVariant.Ed25519:\n        return new AnyPublicKey(Ed25519PublicKey.load(deserializer));\n      case AnyPublicKeyVariant.Secp256k1:\n        return new AnyPublicKey(Secp256k1PublicKey.load(deserializer));\n      default:\n        throw new Error(`Unknown variant index for AnyPublicKey: ${index}`);\n    }\n  }\n\n  static isPublicKey(publicKey: PublicKey): publicKey is AnyPublicKey {\n    return publicKey instanceof AnyPublicKey;\n  }\n\n  isEd25519(): this is Ed25519PublicKey {\n    return this.publicKey instanceof Ed25519PublicKey;\n  }\n\n  isSecp256k1PublicKey(): this is Secp256k1PublicKey {\n    return this.publicKey instanceof Secp256k1PublicKey;\n  }\n}\n"],"mappings":"2HAeO,IAAMA,EAAN,MAAMC,UAAqBC,CAAU,CAM1C,YAAYC,EAAsB,CAChC,MAAM,EACN,KAAK,UAAYA,CACnB,CAOA,cAA2B,CACzB,OAAO,KAAK,UAAU,aAAa,CACrC,CAOA,UAAmB,CACjB,OAAO,KAAK,UAAU,SAAS,CACjC,CASA,gBAAgBC,EAA+D,CAC7E,GAAM,CAAE,QAAAC,EAAS,UAAAC,CAAU,EAAIF,EAC/B,OAAO,KAAK,UAAU,gBAAgB,CAAE,QAAAC,EAAS,UAAAC,CAAU,CAAC,CAC9D,CAEA,UAAUC,EAA8B,CACtC,GAAI,KAAK,qBAAqBC,EAC5BD,EAAW,uBAAiD,EAC5D,KAAK,UAAU,UAAUA,CAAU,UAC1B,KAAK,qBAAqBE,EACnCF,EAAW,uBAAmD,EAC9D,KAAK,UAAU,UAAUA,CAAU,MAEnC,OAAM,IAAI,MAAM,yBAAyB,CAE7C,CAEA,OAAO,YAAYG,EAA0C,CAC3D,IAAMC,EAAQD,EAAa,wBAAwB,EACnD,OAAQC,EAAO,CACb,OACE,OAAO,IAAIV,EAAaO,EAAiB,KAAKE,CAAY,CAAC,EAC7D,OACE,OAAO,IAAIT,EAAaQ,EAAmB,KAAKC,CAAY,CAAC,EAC/D,QACE,MAAM,IAAI,MAAM,2CAA2CC,CAAK,EAAE,CACtE,CACF,CAEA,OAAO,YAAYR,EAAiD,CAClE,OAAOA,aAAqBF,CAC9B,CAEA,WAAsC,CACpC,OAAO,KAAK,qBAAqBO,CACnC,CAEA,sBAAmD,CACjD,OAAO,KAAK,qBAAqBC,CACnC,CACF","names":["AnyPublicKey","_AnyPublicKey","PublicKey","publicKey","args","message","signature","serializer","Ed25519PublicKey","Secp256k1PublicKey","deserializer","index"]}